!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
COMPILER	Makefile	/^COMPILER = g++$/;"	m
FLAGS	Makefile	/^FLAGS = -g -Wall  -I\/usr\/local\/Cellar\/gsl\/1.16\/include -std=c++11$/;"	m
LIBS	Makefile	/^LIBS = -lgsl -lgslcblas -L\/usr\/local\/Cellar\/gsl\/1.16\/lib$/;"	m
OBJS	Makefile	/^OBJS = utils.o topic.o document.o corpus.o gibbs.o hdp_main.o$/;"	m
SOURCE	Makefile	/^SOURCE = $(OBJS:.o=.cc)$/;"	m
AlphaScore	corpus.cc	/^double CorpusUtils::AlphaScore(Corpus* corpus) {$/;"	f	class:hdp::CorpusUtils
BUF_SIZE	corpus.cc	/^#define BUF_SIZE /;"	d	file:
Corpus	corpus.cc	/^Corpus::Corpus()$/;"	f	class:hdp::Corpus
Corpus	corpus.cc	/^Corpus::Corpus(double gamma, double alpha)$/;"	f	class:hdp::Corpus
PermuteDocuments	corpus.cc	/^void CorpusUtils::PermuteDocuments(Corpus* corpus) {$/;"	f	class:hdp::CorpusUtils
ReadCorpus	corpus.cc	/^void CorpusUtils::ReadCorpus($/;"	f	class:hdp::CorpusUtils
hdp	corpus.cc	/^namespace hdp {$/;"	n	file:
CORPUS_H_	corpus.h	/^#define CORPUS_H_$/;"	d
Corpus	corpus.h	/^class Corpus {$/;"	c	namespace:hdp
CorpusUtils	corpus.h	/^class CorpusUtils {$/;"	c	namespace:hdp
addDocument	corpus.h	/^  void addDocument(const Document& document) {$/;"	f	class:hdp::Corpus
alpha_	corpus.h	/^  double alpha_;$/;"	m	class:hdp::Corpus
documents_	corpus.h	/^  vector<Document> documents_;$/;"	m	class:hdp::Corpus
gamma_	corpus.h	/^  double gamma_;$/;"	m	class:hdp::Corpus
getAlpha	corpus.h	/^  int getAlpha() const { return alpha_; }$/;"	f	class:hdp::Corpus
getDocuments	corpus.h	/^  int getDocuments() const { return documents_.size(); }$/;"	f	class:hdp::Corpus
getGamma	corpus.h	/^  int getGamma() const { return gamma_; }$/;"	f	class:hdp::Corpus
getMutableDocument	corpus.h	/^  Document* getMutableDocument(int i) { return &documents_.at(i); }$/;"	f	class:hdp::Corpus
getWordNo	corpus.h	/^  int getWordNo() const { return word_no_; }$/;"	f	class:hdp::Corpus
getWordTotal	corpus.h	/^  int getWordTotal() const { return word_total_; }$/;"	f	class:hdp::Corpus
hdp	corpus.h	/^namespace hdp {$/;"	n
setAlpha	corpus.h	/^  void setAlpha(int alpha) { alpha_ = alpha; }$/;"	f	class:hdp::Corpus
setDocuments	corpus.h	/^  void setDocuments(const vector<Document>& documents) {$/;"	f	class:hdp::Corpus
setGamma	corpus.h	/^  void setGamma(int gamma) { gamma_ = gamma; }$/;"	f	class:hdp::Corpus
setWordNo	corpus.h	/^  void setWordNo(int word_no) { word_no_ = word_no; }$/;"	f	class:hdp::Corpus
setWordTotal	corpus.h	/^  void setWordTotal(int word_total) { word_total_ = word_total; }$/;"	f	class:hdp::Corpus
word_no_	corpus.h	/^  int word_no_;$/;"	m	class:hdp::Corpus
word_total_	corpus.h	/^  int word_total_;$/;"	m	class:hdp::Corpus
AlphaScore	document.cc	/^double DocumentUtils::AlphaScore(Document* document, $/;"	f	class:hdp::DocumentUtils
CompactTables	document.cc	/^void DocumentUtils::CompactTables(Document* document) {$/;"	f	class:hdp::DocumentUtils
Document	document.cc	/^Document::Document(int id) $/;"	f	class:hdp::Document
GetWordsAndCounts	document.cc	/^void TableUtils::GetWordsAndCounts(Table* table,$/;"	f	class:hdp::TableUtils
PermuteWords	document.cc	/^void DocumentUtils::PermuteWords(Document* document) {$/;"	f	class:hdp::DocumentUtils
SampleTableForWord	document.cc	/^void DocumentUtils::SampleTableForWord(Document* document,$/;"	f	class:hdp::DocumentUtils
SampleTables	document.cc	/^void DocumentUtils::SampleTables(Document* document,$/;"	f	class:hdp::DocumentUtils
SampleTopicForTable	document.cc	/^void TableUtils::SampleTopicForTable(Table* table, $/;"	f	class:hdp::TableUtils
SampleTopics	document.cc	/^void DocumentUtils::SampleTopics(Document* document, double gamma) {$/;"	f	class:hdp::DocumentUtils
Table	document.cc	/^Table::Table()$/;"	f	class:hdp::Table
Table	document.cc	/^Table::Table(int word_count)$/;"	f	class:hdp::Table
UpdateTableFromWord	document.cc	/^void WordUtils::UpdateTableFromWord(Word* word,$/;"	f	class:hdp::WordUtils
UpdateTopicFromTable	document.cc	/^void TableUtils::UpdateTopicFromTable(Table* table,$/;"	f	class:hdp::TableUtils
Word	document.cc	/^Word::Word(int id) $/;"	f	class:hdp::Word
getCountById	document.cc	/^int Table::getCountById(int word_id) {$/;"	f	class:hdp::Table
hdp	document.cc	/^namespace hdp {$/;"	n	file:
removeTable	document.cc	/^void Document::removeTable(int pos) {$/;"	f	class:hdp::Document
updateMapWordCount	document.cc	/^void Table::updateMapWordCount(int word_id, int update) {$/;"	f	class:hdp::Table
~Document	document.cc	/^Document::~Document() {$/;"	f	class:hdp::Document
~Word	document.cc	/^Word::~Word() {}$/;"	f	class:hdp::Word
DOCUMENT_H_	document.h	/^#define DOCUMENT_H_$/;"	d
Document	document.h	/^class Document {$/;"	c	namespace:hdp
DocumentUtils	document.h	/^class DocumentUtils {$/;"	c	namespace:hdp
Table	document.h	/^class Table {$/;"	c	namespace:hdp
TableUtils	document.h	/^class TableUtils {$/;"	c	namespace:hdp
Word	document.h	/^class Word {$/;"	c	namespace:hdp
WordUtils	document.h	/^class WordUtils {$/;"	c	namespace:hdp
addNewTable	document.h	/^	void addNewTable() {$/;"	f	class:hdp::Document
addWord	document.h	/^	void addWord(const Word& word) { words_.push_back(word); }$/;"	f	class:hdp::Document
addWord	document.h	/^	void addWord(int id) { words_.push_back(Word(id)); }$/;"	f	class:hdp::Document
getId	document.h	/^	int getId() const { return id_; }$/;"	f	class:hdp::Document
getId	document.h	/^	int getId() const { return id_; }$/;"	f	class:hdp::Word
getMapWordCount	document.h	/^	unordered_map<int, int>& getMapWordCount() { return map_word_count_; }$/;"	f	class:hdp::Table
getMutableTable	document.h	/^	Table* getMutableTable() { return table_; }$/;"	f	class:hdp::Word
getMutableTable	document.h	/^	Table* getMutableTable(int i) { return tables_[i]; }$/;"	f	class:hdp::Document
getMutableTopic	document.h	/^	Topic* getMutableTopic() { return topic_; }$/;"	f	class:hdp::Table
getMutableWord	document.h	/^	Word* getMutableWord(int i) { return &(words_[i]); }$/;"	f	class:hdp::Document
getTables	document.h	/^	int getTables() { return tables_.size(); }$/;"	f	class:hdp::Document
getWordCount	document.h	/^	int getWordCount() const { return word_count_; }$/;"	f	class:hdp::Table
getWords	document.h	/^	int getWords() { return words_.size(); }$/;"	f	class:hdp::Document
hdp	document.h	/^namespace hdp {$/;"	n
id_	document.h	/^	int id_;$/;"	m	class:hdp::Document
id_	document.h	/^	int id_;$/;"	m	class:hdp::Word
incWordCount	document.h	/^	void incWordCount(int val) { word_count_ += val; }$/;"	f	class:hdp::Table
map_word_count_	document.h	/^	unordered_map<int, int> map_word_count_;$/;"	m	class:hdp::Table
setId	document.h	/^	void setId(const int id) { id_ = id; }$/;"	f	class:hdp::Document
setId	document.h	/^	void setId(const int& id) { id_ = id; }$/;"	f	class:hdp::Word
setTable	document.h	/^	void setTable(Table* table) { table_ = table; }$/;"	f	class:hdp::Word
setTopic	document.h	/^	void setTopic(Topic* topic) { topic_ = topic; }$/;"	f	class:hdp::Table
setWordCount	document.h	/^	void setWordCount(const int& word_count) { word_count_ = word_count; }$/;"	f	class:hdp::Table
setWords	document.h	/^	void setWords(const vector<Word>& words) {$/;"	f	class:hdp::Document
table_	document.h	/^	Table* table_;$/;"	m	class:hdp::Word
tables_	document.h	/^	vector<Table*> tables_;  $/;"	m	class:hdp::Document
topic_	document.h	/^	Topic* topic_;$/;"	m	class:hdp::Table
word_count_	document.h	/^	int word_count_;$/;"	m	class:hdp::Table
words_	document.h	/^	vector<Word> words_;$/;"	m	class:hdp::Document
BUF_SIZE	gibbs.cc	/^#define BUF_SIZE /;"	d	file:
DEFAULT_HYPER_LAG	gibbs.cc	/^#define DEFAULT_HYPER_LAG /;"	d	file:
DEFAULT_SAMPLE_ETA	gibbs.cc	/^#define DEFAULT_SAMPLE_ETA /;"	d	file:
DEFAULT_SAMPLE_GAMMA	gibbs.cc	/^#define DEFAULT_SAMPLE_GAMMA /;"	d	file:
DEFAULT_SHUFFLE_LAG	gibbs.cc	/^#define DEFAULT_SHUFFLE_LAG /;"	d	file:
DEFUALT_SAMPLE_ALPHA	gibbs.cc	/^#define DEFUALT_SAMPLE_ALPHA /;"	d	file:
GibbsState	gibbs.cc	/^GibbsState::GibbsState()$/;"	f	class:hdp::GibbsState
InitGibbsState	gibbs.cc	/^void GibbsSampler::InitGibbsState($/;"	f	class:hdp::GibbsSampler
InitGibbsStateRep	gibbs.cc	/^GibbsState* GibbsSampler::InitGibbsStateRep($/;"	f	class:hdp::GibbsSampler
IterateGibbsState	gibbs.cc	/^void GibbsSampler::IterateGibbsState(GibbsState* gibbs_state) {$/;"	f	class:hdp::GibbsSampler
REP_NO	gibbs.cc	/^#define REP_NO /;"	d	file:
ReadGibbsInput	gibbs.cc	/^void GibbsSampler::ReadGibbsInput($/;"	f	class:hdp::GibbsSampler
computeGibbsScore	gibbs.cc	/^double GibbsState::computeGibbsScore() {$/;"	f	class:hdp::GibbsState
hdp	gibbs.cc	/^namespace hdp {$/;"	n	file:
GIBBS_H_	gibbs.h	/^#define GIBBS_H_$/;"	d
GibbsSampler	gibbs.h	/^class GibbsSampler {$/;"	c	namespace:hdp
GibbsState	gibbs.h	/^class GibbsState {$/;"	c	namespace:hdp
alpha_score_	gibbs.h	/^  double alpha_score_;$/;"	m	class:hdp::GibbsState
corpus_	gibbs.h	/^  Corpus corpus_;$/;"	m	class:hdp::GibbsState
eta_score_	gibbs.h	/^  double eta_score_;$/;"	m	class:hdp::GibbsState
gamma_score_	gibbs.h	/^  double gamma_score_;$/;"	m	class:hdp::GibbsState
getAlphaScore	gibbs.h	/^  double getAlphaScore() const { return alpha_score_; }$/;"	f	class:hdp::GibbsState
getEtaScore	gibbs.h	/^  double getEtaScore() const { return eta_score_; }$/;"	f	class:hdp::GibbsState
getGammaScore	gibbs.h	/^  double getGammaScore() const { return gamma_score_; }$/;"	f	class:hdp::GibbsState
getHyperLag	gibbs.h	/^  int getHyperLag() const { return hyper_lag_; }$/;"	f	class:hdp::GibbsState
getIteration	gibbs.h	/^  int getIteration() const { return iteration_; }$/;"	f	class:hdp::GibbsState
getMaxScore	gibbs.h	/^  double getMaxScore() const { return max_score_; }$/;"	f	class:hdp::GibbsState
getMutableCorpus	gibbs.h	/^  Corpus* getMutableCorpus() { return &corpus_; }$/;"	f	class:hdp::GibbsState
getSampleAlpha	gibbs.h	/^  int getSampleAlpha() const { return sample_alpha_; }$/;"	f	class:hdp::GibbsState
getSampleEta	gibbs.h	/^  int getSampleEta() const { return sample_eta_; }$/;"	f	class:hdp::GibbsState
getSampleGamma	gibbs.h	/^  int getSampleGamma() const { return sample_gamma_; }$/;"	f	class:hdp::GibbsState
getScore	gibbs.h	/^  double getScore() const { return score_; }$/;"	f	class:hdp::GibbsState
getShuffleLag	gibbs.h	/^  int getShuffleLag() const { return shuffle_lag_; }$/;"	f	class:hdp::GibbsState
hdp	gibbs.h	/^namespace hdp {$/;"	n
hyper_lag_	gibbs.h	/^  int hyper_lag_;$/;"	m	class:hdp::GibbsState
incIteration	gibbs.h	/^  void incIteration(int val) { iteration_ += val; }$/;"	f	class:hdp::GibbsState
iteration_	gibbs.h	/^  int iteration_;$/;"	m	class:hdp::GibbsState
max_score_	gibbs.h	/^  double max_score_;$/;"	m	class:hdp::GibbsState
sample_alpha_	gibbs.h	/^  int sample_alpha_;$/;"	m	class:hdp::GibbsState
sample_eta_	gibbs.h	/^  int sample_eta_;$/;"	m	class:hdp::GibbsState
sample_gamma_	gibbs.h	/^  int sample_gamma_;$/;"	m	class:hdp::GibbsState
score_	gibbs.h	/^  double score_;$/;"	m	class:hdp::GibbsState
setAlphaScore	gibbs.h	/^  void setAlphaScore(double alpha_score) { alpha_score_ = alpha_score; }$/;"	f	class:hdp::GibbsState
setCorpus	gibbs.h	/^  void setCorpus(const Corpus& corpus) { corpus_ = corpus; }$/;"	f	class:hdp::GibbsState
setEtaScore	gibbs.h	/^  void setEtaScore(double eta_score) { eta_score_ = eta_score; }$/;"	f	class:hdp::GibbsState
setGammaScore	gibbs.h	/^  void setGammaScore(double gamma_score) { gamma_score_ = gamma_score; }$/;"	f	class:hdp::GibbsState
setIteration	gibbs.h	/^  void setIteration(int iteration) { iteration_ = iteration; }$/;"	f	class:hdp::GibbsState
setMaxScore	gibbs.h	/^  void setMaxScore(double max_score) { max_score_ = max_score; }$/;"	f	class:hdp::GibbsState
setSampleAlpha	gibbs.h	/^  void setSampleAlpha(int sample_alpha) { sample_alpha_ = sample_alpha; }$/;"	f	class:hdp::GibbsState
setSampleEta	gibbs.h	/^  void setSampleEta(int sample_eta) { sample_eta_ = sample_eta; }$/;"	f	class:hdp::GibbsState
setSampleGamma	gibbs.h	/^  void setSampleGamma(int sample_gamma) { sample_gamma_ = sample_gamma; }$/;"	f	class:hdp::GibbsState
setScore	gibbs.h	/^  void setScore(double score) { score_ = score; }$/;"	f	class:hdp::GibbsState
shuffle_lag_	gibbs.h	/^  int shuffle_lag_;$/;"	m	class:hdp::GibbsState
MAX_ITERATIONS	hdp_main.cc	/^#define MAX_ITERATIONS /;"	d	file:
main	hdp_main.cc	/^int main(int argc, char** argv) {$/;"	f
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
main	test.cc	/^int main() {$/;"	f
EtaScore	topic.cc	/^double AllTopicsUtils::EtaScore() {$/;"	f	class:hdp::AllTopicsUtils
EtaScore	topic.cc	/^double TopicUtils::EtaScore(Topic* topic, double eta) {$/;"	f	class:hdp::TopicUtils
GammaScore	topic.cc	/^double AllTopicsUtils::GammaScore(double gamma) {$/;"	f	class:hdp::AllTopicsUtils
GetInstance	topic.cc	/^AllTopics& AllTopics::GetInstance() {$/;"	f	class:hdp::AllTopics
LogGammaRatio	topic.cc	/^double TopicTableUtils::LogGammaRatio(Table* table,$/;"	f	class:hdp::TopicTableUtils
Topic	topic.cc	/^Topic::Topic(int corpus_word_no)$/;"	f	class:hdp::Topic
addNewTopic	topic.cc	/^void AllTopics::addNewTopic(int corpus_word_no) {$/;"	f	class:hdp::AllTopics
compactTopics	topic.cc	/^void AllTopics::compactTopics() {$/;"	f	class:hdp::AllTopics
getTopicWords	topic.cc	/^int Topic::getTopicWords() const {$/;"	f	class:hdp::Topic
hdp	topic.cc	/^namespace hdp {$/;"	n	file:
removeLastTopic	topic.cc	/^void AllTopics::removeLastTopic() {$/;"	f	class:hdp::AllTopics
removeTopic	topic.cc	/^void AllTopics::removeTopic(Topic* topic) {$/;"	f	class:hdp::AllTopics
removeTopic	topic.cc	/^void AllTopics::removeTopic(int pos) {$/;"	f	class:hdp::AllTopics
updateWordCounts	topic.cc	/^void Topic::updateWordCounts(int word_id, int update) {$/;"	f	class:hdp::Topic
~AllTopics	topic.cc	/^AllTopics::~AllTopics() {$/;"	f	class:hdp::AllTopics
AllTopics	topic.h	/^	AllTopics() { }$/;"	f	class:hdp::AllTopics
AllTopics	topic.h	/^class AllTopics {$/;"	c	namespace:hdp
AllTopicsUtils	topic.h	/^class AllTopicsUtils {$/;"	c	namespace:hdp
TOPIC_H_	topic.h	/^#define TOPIC_H_$/;"	d
Topic	topic.h	/^class Topic {$/;"	c	namespace:hdp
TopicTableUtils	topic.h	/^class TopicTableUtils {$/;"	c	namespace:hdp
TopicUtils	topic.h	/^class TopicUtils {$/;"	c	namespace:hdp
corpus_word_no_	topic.h	/^	int corpus_word_no_;$/;"	m	class:hdp::Topic
eta_	topic.h	/^	double eta_; $/;"	m	class:hdp::AllTopics
getCorpusWordNo	topic.h	/^	int getCorpusWordNo() const { return corpus_word_no_; }$/;"	f	class:hdp::Topic
getEta	topic.h	/^	int getEta() const { return eta_; }$/;"	f	class:hdp::AllTopics
getLgamWordEta	topic.h	/^	double getLgamWordEta(int word_id) const { return lgam_word_eta_[word_id]; }$/;"	f	class:hdp::Topic
getLogWordPr	topic.h	/^	double getLogWordPr(int word_id) const { return log_word_pr_[word_id]; }$/;"	f	class:hdp::Topic
getMutableTopic	topic.h	/^	Topic* getMutableTopic(int i) {$/;"	f	class:hdp::AllTopics
getTableCount	topic.h	/^	int getTableCount() const { return table_count_; }$/;"	f	class:hdp::Topic
getTopicWordNo	topic.h	/^	int getTopicWordNo() const { return topic_word_no_; }$/;"	f	class:hdp::Topic
getTopics	topic.h	/^	int getTopics() const { return topic_ptrs_.size(); }$/;"	f	class:hdp::AllTopics
getWordCount	topic.h	/^	int getWordCount(int word_id) const { return word_counts_[word_id]; }$/;"	f	class:hdp::Topic
hdp	topic.h	/^namespace hdp {$/;"	n
incTableCount	topic.h	/^	void incTableCount(int val) { table_count_ += val; }$/;"	f	class:hdp::Topic
incTopicWordNo	topic.h	/^	void incTopicWordNo(int val) { topic_word_no_ += val; }$/;"	f	class:hdp::Topic
lgam_word_eta_	topic.h	/^	vector<double> lgam_word_eta_; $/;"	m	class:hdp::Topic
log_word_pr_	topic.h	/^	vector<double> log_word_pr_;$/;"	m	class:hdp::Topic
setCorpusWordNO	topic.h	/^	void setCorpusWordNO(int corpus_word_no) { corpus_word_no_ = corpus_word_no; }$/;"	f	class:hdp::Topic
setEta	topic.h	/^	void setEta(const int& eta) { eta_ = eta; }$/;"	f	class:hdp::AllTopics
setTableCount	topic.h	/^	void setTableCount(int table_count) { table_count = table_count_; }$/;"	f	class:hdp::Topic
setTopicWordNo	topic.h	/^	void setTopicWordNo(int topic_word_no) { topic_word_no_ = topic_word_no; }$/;"	f	class:hdp::Topic
table_count_	topic.h	/^	int table_count_;$/;"	m	class:hdp::Topic
topic_ptrs_	topic.h	/^	vector<Topic*> topic_ptrs_;$/;"	m	class:hdp::AllTopics
topic_word_no_	topic.h	/^	int topic_word_no_;$/;"	m	class:hdp::Topic
word_counts_	topic.h	/^	vector<int> word_counts_;$/;"	m	class:hdp::Topic
InitRandomNumberGen	utils.cc	/^void Utils::InitRandomNumberGen(long rng_seed) {$/;"	f	class:hdp::Utils
LogSum	utils.cc	/^double Utils::LogSum(double log_a, double log_b) {$/;"	f	class:hdp::Utils
RANDNUMGEN	utils.cc	/^gsl_rng* Utils::RANDNUMGEN = NULL;$/;"	m	class:hdp::Utils	file:
RandGauss	utils.cc	/^double Utils::RandGauss(double mean, double stdev) {$/;"	f	class:hdp::Utils
RandNo	utils.cc	/^double Utils::RandNo() {$/;"	f	class:hdp::Utils
SampleFromLogPr	utils.cc	/^int Utils::SampleFromLogPr(const vector<double>& log_pr) {$/;"	f	class:hdp::Utils
Shuffle	utils.cc	/^void Utils::Shuffle(gsl_permutation* permutation, int size) {$/;"	f	class:hdp::Utils
Sum	utils.cc	/^double Utils::Sum(const vector<double>& v) {$/;"	f	class:hdp::Utils
hdp	utils.cc	/^namespace hdp {$/;"	n	file:
RANDNUMGEN	utils.h	/^  static gsl_rng* RANDNUMGEN;$/;"	m	class:hdp::Utils
UTILS_H_	utils.h	/^#define UTILS_H_$/;"	d
Utils	utils.h	/^class Utils {$/;"	c	namespace:hdp
hdp	utils.h	/^namespace hdp {$/;"	n
removeFromVec	utils.h	/^void removeFromVec(vector<T*>& v, T* target) {$/;"	f	namespace:hdp
removeFromVec	utils.h	/^void removeFromVec(vector<T>& v, T target) {$/;"	f	namespace:hdp
